---
layout:     post
title:      计算机网络习题讲解
subtitle:   计算机网络第七版
date:       2019-10-19
author:     jxb2018
header-img: img/net/net_top.jpg
catalog: 	 true
tags:
    - 计算机网络
---
# 计算机网络习题讲解
## 习题一 : 试在下列条件下比较电路交换和分组交换。

> 题目

- 要传送的报文共 ```x (bit)```
- 从源点到终点共经过 ```k``` 段链路，每段链路的传播时延为 ```d (s)```
- 在**电路交换**时，电路的建立时间为 ```s (s)```
- 在**分组交换**时，分组长度为 ```p (bit)```,且各结点的排队等候时间可忽略不计。
  
> 问题:  在怎样的条件下，分组交换的时延比电路交换的要小 ?


### 求解分组交换的时延 ```t```<sub>``` 分组交换```</sub>

![image](https://jxb2018.github.io/img/net/delay_fenzu.png)

>   ```t```<sub>```分组时延```</sub> =  ```t```<sub>```发送时延```</sub> ```+``` ```t```<sub>```排队时延```</sub> ```+``` ```t```<sub>```处理时延```</sub> ```+``` ```t```<sub>```传播时延```</sub>

> 时延的分类

- 发送时延
  - 含义: 主机或路由器发送数据帧所需要的时间
  -  ```t```<sub>```发送时延``` = ```数据帧长度\数据率```
- 排队时延
  - 含义: 数据包在路由器的输出队列中等待处理所耗费的时间
- 处理时延
  - 含义: 路由器处理数据包所花费的时间。
  - 举例: 比如说，路由器要解包，进行差错校验、查找下一条合适的路由；还有重新封装
- 传播时延
  - 含义: 数据包走在路上花费的时间(在信道中传输所耗费的时间)

> 具体求解

值得注意的是,由题意可知，处理、排队所花费的时间不计。

不难理解，只有当Host B接收到 Host A所发送的最后一个Bit时，传输才算结束！那我们不妨跟着最后一个Bit来进行一场旅行。
- 首先，主机A将一个```x (bit)```大小的报文发送到信道上，所花费的时间是 ```x/b```。此时最后一个Bit刚刚上路~
- 虽然最后一个Bit出发的很晚，但是，它依然需要走```k```段链路，每段花费的时间都是```d```，所以在路上就花费了```k*d```这么多的时间
- 不光在路上要花费时间,最后一个Bit还要过```k-1```道安检(路由器)。每次安检(路由器存储转发)，要花费```p/b```这么多的时间(存储转发的时间，不计排队和处理的时间))
- 算下来的话，一共需要花费 ```x/b + k*d + (k-1)*(p/b)```这么多的时间

### 求解电路交换的时延 ```t```<sub>``` 电路交换```</sub>
![image](https://jxb2018.github.io/img/net/dianlu.png)

> 电路交换，传输报文的延时主要在于建立电路花费的时间、将报文发送到信道上花费的时间、以及报文走在路上花费的时间(传播时延)

>具体求解

- 建立电路花费的时间是 ```s```
- 将报文发送到信道上花费的时间是 ```x/b```
- 走在路上花费的时间是 ```k*d```
- 所以，一共花费的时间是 ```s``` + ```x/b``` + ```k*d```

### 总结

回到问题上来，不难得到，只要令 ```t```<sub>```分组交换```</sub> < ```t```<sub>```电路交换```便能得出最后的结果。


## 习题二 : 在上题的的分组交换网中

> 题目

- 设报文的长度和分组的长度分别为```x```和```(p+h) (bit)```
  - 其中```p```为分组的数据部分的长度
  - ```h```为每个分组所带的控制信息固定长度，与```p```的大小无关
- 通信的两端共经过```k```段链路
- 链路的数据率为```b (bit/s)```
- 传播时延和结点的排队时间均可忽略不计

> 问题

- 如果打算使总的时延为最小，问分组的数据部分长度```p```应该取为多大
  
> 解答

- 不难知道，要Host A 要向 Host B发送的总的数据大小为 ```(x/p)*(p+h)```,那么Host A将所有的数据发送完，就需要```(x/p)*(p+h)/b```
- 依然以最后一个Bit作为参照,它需要经过```k```段链路，花费```k*d```这么多的时间
- 需要经过```(k-1)```各路由，每次耽误```(p+h)/b```；要经过这么多路由就要花```(k-1)*(p+h)/b```这么多的时间
- 总的来说，花费了```(x/p)*(p+h)/b + k*d + (k-1)*(p+h)/b```这么多的时间
  
> 总结

- 不难知道,这是一个关于```p```的函数，只需要关于```p```进行求导，令其为零，就可以得到使总时延达到最小时```p```的取值。
















